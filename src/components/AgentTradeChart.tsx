/**
 * AgentTradeChart.tsx
 *
 * Shows the real daily close-price series for an agent's assigned crypto
 * asset, overlaid with ▲ entry and ▼ exit signals generated by the
 * SMA crossover backtest engine.
 *
 * ─── SIGNAL DEFINITIONS ──────────────────────────────────────────────────────
 * Entry (▲ green):  SMA_fast just crossed above SMA_slow  (golden cross).
 *                   The agent initiates a long position at this bar's close.
 * Exit  (▼ red):    SMA_fast just crossed below SMA_slow  (death cross).
 *                   The agent fully exits at this bar's close.
 *
 * Between a golden cross and the next death cross, the position is
 * continuously rebalanced daily as the signal strength σ changes, but
 * only the two discrete crossover events are shown here for readability.
 *
 * ─── ARCHITECTURE DISCLOSURES ────────────────────────────────────────────────
 * • Execution assumed at the same daily close that triggers the signal.
 *   Real execution would face slippage, latency, and typically be next-day
 *   open — introducing a 1-day lag and overnight gap risk.
 * • No transaction costs modelled (Binance spot maker: ~0.10%; taker: ~0.10%).
 * • Cross-detection uses end-of-day SMA values computed from prefix sums
 *   (O(n) time) — not rolling windows, so precisely equivalent but faster.
 * • Multiple partial rebalances between crossovers are NOT shown as signals;
 *   they affect the equity curve but not the entry/exit count shown here.
 */

import { useState, useMemo, useCallback } from "react";
import {
  ComposedChart, Line, XAxis, YAxis, Tooltip,
  ResponsiveContainer, CartesianGrid,
} from "recharts";
import { AgentGenome } from "@/data/types";
import {
  BacktestResult, TradeSignal,
  decodeFastMA, decodeSlowMA, assetSymbol,
} from "@/lib/backtest";
import { PriceHistory, SYMBOL_LABEL } from "@/lib/priceData";
import { motion } from "framer-motion";

interface Props {
  agents: AgentGenome[];
  results: Record<string, BacktestResult>;
  priceHistory: PriceHistory;
  /** True once at least one symbol has ≥50 bars from Binance/IndexedDB */
  priceLoaded?: boolean;
}

// ─── Signal-marker SVG shapes ─────────────────────────────────────────────────

function EntryDot({ cx = 0, cy = 0 }: { cx?: number; cy?: number }) {
  return (
    <polygon
      points={`${cx},${cy - 9} ${cx - 5},${cy + 2} ${cx + 5},${cy + 2}`}
      fill="hsl(160 100% 45%)"
      stroke="hsl(220 18% 7%)"
      strokeWidth={0.5}
      opacity={0.9}
    />
  );
}

function ExitDot({ cx = 0, cy = 0 }: { cx?: number; cy?: number }) {
  return (
    <polygon
      points={`${cx},${cy + 9} ${cx - 5},${cy - 2} ${cx + 5},${cy - 2}`}
      fill="hsl(0 72% 51%)"
      stroke="hsl(220 18% 7%)"
      strokeWidth={0.5}
      opacity={0.9}
    />
  );
}

// ─── Custom tooltip ───────────────────────────────────────────────────────────

function PriceTooltip({ active, payload, label, signalMap }: {
  active?: boolean;
  payload?: { value: number }[];
  label?: string;
  signalMap: Map<string, TradeSignal>;
}) {
  if (!active || !payload?.length) return null;
  const price = payload[0]?.value;
  const signal = label ? signalMap.get(label) : undefined;
  return (
    <div style={{
      backgroundColor: "hsl(220 18% 7%)",
      border: "1px solid hsl(220 16% 14%)",
      borderRadius: 8, padding: "8px 12px",
      fontSize: 11, fontFamily: "JetBrains Mono, monospace",
    }}>
      <div style={{ color: "hsl(215 12% 60%)", marginBottom: 4 }}>{label}</div>
      <div style={{ color: "hsl(195 100% 50%)", fontWeight: 700 }}>
        {price >= 1000
          ? `$${price.toLocaleString("en-US", { maximumFractionDigits: 0 })}`
          : `$${price.toFixed(4)}`}
      </div>
      {signal && (
        <div style={{
          marginTop: 4,
          color: signal.action === "entry" ? "hsl(160 100% 45%)" : "hsl(0 72% 51%)",
          fontWeight: 600,
        }}>
          {signal.action === "entry" ? "▲ GOLDEN CROSS — entry" : "▼ DEATH CROSS — exit"}
          <div style={{ fontWeight: 400, opacity: 0.7 }}>
            {signal.action === "entry"
              ? `target exposure: ${(signal.exposure * 100).toFixed(1)}%`
              : "flatten to 0%"}
          </div>
        </div>
      )}
    </div>
  );
}

// ─── Formula panel ────────────────────────────────────────────────────────────

function Row({ label, value, note }: { label: string; value: string; note?: string }) {
  return (
    <div className="grid grid-cols-[150px_1fr] gap-2 py-[3px] border-b border-border/20 last:border-0">
      <span className="font-mono text-[10px] text-muted-foreground leading-tight">{label}</span>
      <div className="min-w-0">
        <code className="text-[10px] text-foreground break-all leading-tight">{value}</code>
        {note && <span className="ml-2 text-[9px] text-muted-foreground/60">{note}</span>}
      </div>
    </div>
  );
}

function Section({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="rounded-md border border-border/40 bg-secondary/15 px-3 py-2.5 space-y-[2px]">
      <p className="text-[9px] font-bold uppercase tracking-widest text-muted-foreground/50 mb-2">{title}</p>
      {children}
    </div>
  );
}

function FormulaPanel({ agent, result }: { agent: AgentGenome; result: BacktestResult }) {
  const f = result.fastPeriod;
  const s = result.slowPeriod;
  const ra = agent.genome.riskAversion;
  const maxExposurePct = ((1 - ra) * 0.99 * 100).toFixed(1);
  const assetSlot = Math.min(14, Math.max(0, Math.round(agent.genome.assetIdx * 14)));

  // Fitness normalised components
  const sNorm = ((Math.min(Math.max(result.sharpe, -2), 4) + 2) / 6).toFixed(4);
  const rNorm = ((Math.min(Math.max(result.totalReturn, -50), 150) + 50) / 200).toFixed(4);
  const wNorm = (result.winRate / 100).toFixed(4);
  const dNorm = (1 - Math.min(Math.max(result.maxDrawdown, 0), 60) / 60).toFixed(4);

  // Archetype match labels
  const archetypeMatches: Record<string, string> = {
    momentum: f <= 10 && (s - f) <= 25 ? " ← this agent" : "",
    defensive: s >= 130 ? " ← this agent" : "",
    volatility: (s - f) <= 15 ? " ← this agent" : "",
    "mean-reversion": f >= 25 && s >= 80 ? " ← this agent" : "",
    hybrid: agent.archetype === "hybrid" ? " ← this agent" : "",
  };

  return (
    <div className="space-y-2 mt-4">

      <Section title="Entry / Exit Rule">
        <Row label="Entry condition" value={`LONG  when SMA(${f}) > SMA(${s})`} note="golden cross" />
        <Row label="Exit condition" value={`FLAT  when SMA(${f}) ≤ SMA(${s})`} note="death cross — full exit" />
        <Row label="Asset assigned" value={`${result.asset}  [assetIdx gene = ${agent.genome.assetIdx.toFixed(3)} → slot ${assetSlot} / 14]`} />
        <Row label="SMA parameters" value={`fast = ${f} days,  slow = ${s} days`} note="floor(5+v×45) & floor(20+v×180)" />
        <Row label="Short selling" value="None — position is always ≥ 0" />
        <Row label="Leverage" value="None — exposure ∈ [0, 0.99]" />
      </Section>

      <Section title="Position Sizing — Volatility-scaled SMA Spread">
        <Row label="Signal strength σ" value="σ = (SMA_fast − SMA_slow) / SMA_slow" note="dimensionless fractional spread" />
        <Row label="Exposure e" value={`e = (1 − ${ra.toFixed(3)}) × tanh(σ × 15) × 0.99`} />
        <Row label="  → riskAversion" value={ra.toFixed(3)} note="gene value; 0 = max aggression, 1 = always flat" />
        <Row label="  → max exposure" value={`${maxExposurePct}% of equity`} note="at large |σ|, tanh saturates to ≈1" />
        <Row label="  → the ×15 factor" value="scales tanh so σ=0.02 already gives ~30% saturation" note="calibrated heuristic, not derived from vol targeting" />
        <Row label="Dollar position P$" value="P$ = equity × e" note="mark-to-market equity" />
        <Row label="Units held Q" value="Q  = P$ / close_price" />
        <Row label="Rebalance rule" value="|Δe| > 0.01 only" note="ignores sub-1% shifts to reduce churn in choppy regimes" />
      </Section>

      <Section title={`Archetype Classification → "${agent.archetype}"`}>
        <Row label="f≤10 ∧ spread≤25" value={`→ momentum${archetypeMatches.momentum}`} />
        <Row label="s≥130" value={`→ defensive${archetypeMatches.defensive}`} />
        <Row label="spread≤15" value={`→ volatility${archetypeMatches.volatility}`} />
        <Row label="f≥25 ∧ s≥80" value={`→ mean-reversion${archetypeMatches["mean-reversion"]}`} />
        <Row label="else" value={`→ hybrid${archetypeMatches.hybrid}`} />
        <Row label="spread = s − f" value={`${s} − ${f} = ${s - f} days`} />
      </Section>

      <Section title={`Fitness = ${result.fitness.toFixed(1)} / 100  (with agent values)`}>
        <Row label="S* Sharpe" value={`clamp(${result.sharpe.toFixed(3)}, −2, 4) ÷ 6 shifted = ${sNorm}`} note="annualised rf=0; range [−2,4]→[0,1]" />
        <Row label="R* Return%" value={`clamp(${result.totalReturn.toFixed(2)}%, −50, 150) / 200 shifted = ${rNorm}`} note="range [−50,150]→[0,1]" />
        <Row label="W* Win rate" value={`${result.winRate.toFixed(1)}% / 100 = ${wNorm}`} note="round-trip trades only" />
        <Row label="D* Max drawdown" value={`1 − clamp(${result.maxDrawdown.toFixed(2)}%, 0, 60)/60 = ${dNorm}`} />
        <Row
          label="Composite"
          value={`0.40×${sNorm} + 0.30×${rNorm} + 0.20×${wNorm} + 0.10×${dNorm} = ${result.fitness.toFixed(1)}`}
        />
        <Row label="Weight rationale" value="Sharpe dominates (risk-adjusted perf); return second; win-rate third; drawdown hedge" />
      </Section>

      <Section title="Evolution Operators">
        <Row label="Mutation (MUT)" value="±12% Gaussian per gene: v' = clamp(v + (rand−0.5)×0.24, 0, 1)" />
        <Row label="Crossover" value="Uniform blend: v' = a + (b−a)×rand + mutation" />
        <Row label="Cull rate" value="Bottom 20% by fitness per generation → extinct" />
        <Row label="Breed pool" value="Top 30% of survivors chosen as parents" />
        <Row label="Asset inheritance" value="90% chance child inherits parent asset; 10% random new asset" />
      </Section>

      <Section title="Known Simplifications & Look-ahead Biases  ⚠">
        <Row label="Execution lag" value="Signals trigger at daily CLOSE — real orders clear next-day open" />
        <Row label="Transaction costs" value="None (Binance maker ≈0.10%; large positions face slippage)" />
        <Row label="Sharpe rf" value="Risk-free rate = 0;  denominator includes flat (0% return) days → downward bias" />
        <Row label="Sharpe bias ▸" value="Calendar days with e=0 count as 0% return, inflating σ_daily → Sharpe understated" />
        <Row label="Win-rate count" value="Counts full round-trips only; partial rebalances excluded" />
        <Row label="Max drawdown" value="End-of-day MTM only; intraday excursions not observable from daily data" />
        <Row label="Data" value="Binance UTC midnight 1d candles; crypto has no dividends or splits to adjust" />
        <Row label="Look-ahead (minor)" value="Final bar is today's in-progress candle (incomplete close)" />
        <Row label="Backtest overfitting" value="SMA crossovers are one of the most-studied patterns; out-of-sample performance typically degrades significantly" />
        <Row label="Regime independence" value="Backtest ignores EnvironmentState; regime only affects OnboardingModal label — no conditional strategy switching implemented" />
      </Section>

    </div>
  );
}

// ─── Main component ───────────────────────────────────────────────────────────

export default function AgentTradeChart({ agents, results, priceHistory, priceLoaded = true }: Props) {
  const eligible = agents.filter((a) => !!results[a.id]);
  const [selectedId, setSelectedId] = useState<string>(() => eligible[0]?.id ?? "");

  const agent = eligible.find((a) => a.id === selectedId) ?? eligible[0] ?? null;
  const result = agent ? results[agent.id] : null;

  // Raw close-price series for the selected asset
  const priceData = useMemo(() => {
    if (!agent || !result) return [];
    const sym = assetSymbol(agent.genome.assetIdx);
    return (priceHistory[sym] ?? []).map((b) => ({ date: b.date, close: b.close }));
  }, [agent, result, priceHistory]);

  // O(1) signal lookup by date
  const signalMap = useMemo(() => {
    const map = new Map<string, TradeSignal>();
    result?.tradeSignals?.forEach((s) => map.set(s.date, s));
    return map;
  }, [result]);

  // Custom dot: only renders an SVG shape on signal dates
  const renderDot = useCallback(
    (props: { cx?: number; cy?: number; payload?: { date: string }; index?: number }) => {
      const sig = signalMap.get(props?.payload?.date ?? "");
      const key = `dot-${props.index ?? 0}`;
      if (!sig) return <g key={key} />;
      if (sig.action === "entry") return <EntryDot key={key} cx={props.cx} cy={props.cy} />;
      return <ExitDot key={key} cx={props.cx} cy={props.cy} />;
    },
    [signalMap],
  );

  const entryCount = result?.tradeSignals?.filter((s) => s.action === "entry").length ?? 0;
  const exitCount  = result?.tradeSignals?.filter((s) => s.action === "exit").length ?? 0;

  if (eligible.length === 0) {
    const msg = agents.length === 0
      ? "No agents yet — spawn a population first"
      : !priceLoaded
      ? "Price data not loaded — click ↺ Prices in the header to fetch from Binance"
      : "Run a generation to compute SMA signals and plot them on real price data";
    return (
      <div className="space-y-3">
        <h3 className="text-xs font-semibold uppercase tracking-widest text-muted-foreground">
          Agent Trade Chart
        </h3>
        <div className="h-[200px] flex flex-col items-center justify-center gap-2 text-xs text-muted-foreground font-mono text-center px-6">
          <span>{msg}</span>
          {agents.length > 0 && !priceLoaded && (
            <span className="text-[10px] opacity-60">
              Binance API blocked or offline — try refreshing prices or check your network
            </span>
          )}
        </div>
      </div>
    );
  }

  return (
    <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} className="space-y-3">

      {/* Header + agent selector */}
      <div className="flex items-center justify-between gap-3 flex-wrap">
        <h3 className="text-xs font-semibold uppercase tracking-widest text-muted-foreground">
          Agent Trade Chart — Entry / Exit on Real Price
        </h3>
        <select
          value={selectedId}
          onChange={(e) => setSelectedId(e.target.value)}
          className="rounded-md border border-border bg-secondary/60 px-2 py-1 text-[10px] font-mono
                     text-foreground focus:outline-none focus:ring-1 focus:ring-primary/50 cursor-pointer"
        >
          {eligible.map((a) => {
            const r = results[a.id];
            return (
              <option key={a.id} value={a.id}>
                {a.name} ({r?.asset ?? "?"}) · SMA({r?.fastPeriod ?? "?"}/{r?.slowPeriod ?? "?"}) ·
                {" "}{(r?.totalReturn ?? 0) >= 0 ? "+" : ""}{(r?.totalReturn ?? 0).toFixed(1)}% ·
                Sharpe {(r?.sharpe ?? 0).toFixed(2)}
              </option>
            );
          })}
        </select>
      </div>

      {/* Signal legend */}
      {result && (
        <div className="flex items-center gap-5 flex-wrap text-[10px] font-mono text-muted-foreground">
          <span className="flex items-center gap-1.5">
            <svg width="10" height="10" viewBox="0 0 10 10" className="flex-shrink-0">
              <polygon points="5,1 0,10 10,10" fill="hsl(160 100% 45%)" />
            </svg>
            Golden cross (entry) × {entryCount}
          </span>
          <span className="flex items-center gap-1.5">
            <svg width="10" height="10" viewBox="0 0 10 10" className="flex-shrink-0">
              <polygon points="5,10 0,0 10,0" fill="hsl(0 72% 51%)" />
            </svg>
            Death cross (exit) × {exitCount}
          </span>
          <span className="flex items-center gap-1.5 opacity-60">
            SMA({result.fastPeriod}/{result.slowPeriod}) on {result.asset} ·
            {" "}{result.trades} completed round-trips · initial capital $100k
          </span>
        </div>
      )}

      {/* Price chart */}
      {priceData.length > 0 ? (
        <div className="h-[270px]">
          <ResponsiveContainer width="100%" height="100%">
            <ComposedChart data={priceData} margin={{ top: 10, right: 8, left: 0, bottom: 0 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="hsl(220 16% 11%)" vertical={false} />
              <XAxis
                dataKey="date"
                tick={{ fill: "hsl(215 12% 45%)", fontSize: 9, fontFamily: "JetBrains Mono" }}
                tickFormatter={(v: string) => v.slice(0, 7)}
                axisLine={false}
                tickLine={false}
                interval="preserveStartEnd"
              />
              <YAxis
                tick={{ fill: "hsl(215 12% 45%)", fontSize: 9, fontFamily: "JetBrains Mono" }}
                tickFormatter={(v: number) =>
                  v >= 10000
                    ? `$${(v / 1000).toFixed(0)}k`
                    : v >= 1000
                    ? `$${(v / 1000).toFixed(1)}k`
                    : `$${v.toFixed(2)}`
                }
                axisLine={false}
                tickLine={false}
                width={58}
              />
              <Tooltip
                content={(p) => (
                  <PriceTooltip
                    active={p.active}
                    payload={p.payload as { value: number }[] | undefined}
                    label={p.label as string | undefined}
                    signalMap={signalMap}
                  />
                )}
                isAnimationActive={false}
              />
              <Line
                type="monotone"
                dataKey="close"
                stroke="hsl(215 55% 55%)"
                strokeWidth={1.5}
                dot={renderDot}
                activeDot={{ r: 3, strokeWidth: 0, fill: "hsl(195 100% 60%)" }}
                isAnimationActive={false}
              />
            </ComposedChart>
          </ResponsiveContainer>
        </div>
      ) : (
        <div className="h-[270px] flex items-center justify-center text-xs text-muted-foreground font-mono">
          Price data not yet loaded — waiting for Binance fetch
        </div>
      )}

      {/* Formula breakdown */}
      {agent && result && <FormulaPanel agent={agent} result={result} />}

    </motion.div>
  );
}
