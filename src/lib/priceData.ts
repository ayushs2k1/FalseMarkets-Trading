/**
 * priceData.ts — Daily OHLCV from preprocessed Kraken CSV data.
 *
 * DATA SOURCE: Static JSON files at /public/data/{LABEL}.json, generated by
 * scripts/preprocess-prices.mjs which aggregates minute-level Kraken CSVs
 * into one daily bar per UTC calendar day.
 *
 * 28 assets, ~1700–4500 daily bars each. No synthetic data, no API calls.
 *
 * DAILY BAR DEFINITION:
 *   open   = first minute open of the UTC day
 *   high   = max(high)   across all minute bars that day
 *   low    = min(low)    across all minute bars that day
 *   close  = last minute close of the UTC day
 *   volume = sum(volume) across all minute bars
 *
 * CACHE: IndexedDB "apex-price-db" / store "prices", TTL 12 h.
 *   IDB_VERSION bumped to 2 — drops any old Binance/synthetic records.
 *
 * SIMPLIFICATIONS / ASSUMPTIONS:
 *   - USDT and DAI excluded (stablecoins — SMA crossover is meaningless).
 *   - XBT → BTC, XDG → DOGE (Kraken ticker aliases mapped in preprocessing).
 *   - WAVES data ends 2024-03-31; EOS ends 2025-06-30; both included as-is.
 *   - Backtest engine uses only close prices.
 */

// ─── Asset universe ───────────────────────────────────────────────────────────

/**
 * 28 real-data assets from Kraken CSVs.
 * Variable name kept as TOP_15 for backward-compat with backtest.ts imports.
 * (Length is now 28; genome decoder uses floor(v × 27) → indices 0–27.)
 */
export const TOP_15 = [
  "BTC",  "ETH",  "DOGE", "XRP",  "LTC",
  "XLM",  "XMR",  "ADA",  "BCH",  "LINK",
  "ATOM", "ETC",  "ZEC",  "DASH", "EOS",
  "XTZ",  "QTUM", "WAVES","BAT",  "ICX",
  "LSK",  "MLN",  "NANO", "OMG",  "PAXG",
  "REP",  "SC",   "GNO",
] as const;

export type CryptoSymbol = typeof TOP_15[number];

/**
 * Identity map: symbol === label for this dataset (no exchange suffix).
 * All SYMBOL_LABEL[sym] callsites in backtest.ts continue to work.
 */
export const SYMBOL_LABEL: Record<string, string> = Object.fromEntries(
  TOP_15.map((t) => [t, t]),
);

// ─── Types ────────────────────────────────────────────────────────────────────

export interface OHLCVBar {
  ts:     number;   // unix ms (start of UTC day)
  date:   string;   // "YYYY-MM-DD"
  open:   number;
  high:   number;
  low:    number;
  close:  number;
  volume: number;
}

export type PriceHistory = Record<string, OHLCVBar[]>;

// ─── IndexedDB helpers ────────────────────────────────────────────────────────

const IDB_NAME    = "apex-price-db";
const IDB_STORE   = "prices";
const IDB_VERSION = 2;            // bumped from 1 — drops old Binance/synthetic cache
const IDB_TTL     = 12 * 60 * 60 * 1000; // 12 h

interface IDBRecord {
  symbol: string;
  ts:     number;
  bars:   OHLCVBar[];
}

function openDB(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(IDB_NAME, IDB_VERSION);
    req.onupgradeneeded = () => {
      const db = req.result;
      for (const name of Array.from(db.objectStoreNames)) {
        db.deleteObjectStore(name);
      }
      db.createObjectStore(IDB_STORE, { keyPath: "symbol" });
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror   = () => reject(req.error);
  });
}

function idbGet(db: IDBDatabase, symbol: string): Promise<IDBRecord | null> {
  return new Promise((resolve, reject) => {
    const req = db.transaction(IDB_STORE, "readonly").objectStore(IDB_STORE).get(symbol);
    req.onsuccess = () => resolve((req.result as IDBRecord | undefined) ?? null);
    req.onerror   = () => reject(req.error);
  });
}

function idbPut(db: IDBDatabase, record: IDBRecord): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).put(record);
    tx.oncomplete = () => resolve();
    tx.onerror    = () => reject(tx.error);
  });
}

function idbClear(db: IDBDatabase): Promise<void> {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(IDB_STORE, "readwrite");
    tx.objectStore(IDB_STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror    = () => reject(tx.error);
  });
}

// ─── Fetch from static JSON files ────────────────────────────────────────────

async function fetchAsset(label: string): Promise<OHLCVBar[]> {
  const res = await fetch(`/data/${label}.json`);
  if (!res.ok) throw new Error(`/data/${label}.json HTTP ${res.status}`);
  return res.json() as Promise<OHLCVBar[]>;
}

// ─── Public API ───────────────────────────────────────────────────────────────

/**
 * Load all 28 assets. Records younger than 12 h are served from IndexedDB.
 * Stale or missing records are fetched from /public/data/ and persisted.
 * onProgress is called after each asset so the UI can show a loading bar.
 */
export async function loadPriceData(
  onProgress?: (loaded: number, total: number, symbol: string) => void,
): Promise<PriceHistory> {
  const history: PriceHistory = {};
  let db: IDBDatabase | null = null;

  try {
    db = await openDB();
  } catch (e) {
    console.warn("[priceData] IndexedDB unavailable; loading direct from /data/:", e);
  }

  const now = Date.now();

  for (let i = 0; i < TOP_15.length; i++) {
    const label = TOP_15[i];

    if (db) {
      try {
        const cached = await idbGet(db, label);
        if (cached && now - cached.ts < IDB_TTL && cached.bars.length > 50) {
          history[label] = cached.bars;
          onProgress?.(i + 1, TOP_15.length, "cache");
          continue;
        }
      } catch { /* fall through */ }
    }

    try {
      const bars = await fetchAsset(label);
      history[label] = bars;
      if (db) await idbPut(db, { symbol: label, ts: now, bars }).catch(() => {});
    } catch (e) {
      console.warn(`[priceData] Failed to fetch ${label}:`, e);
      history[label] = [];
    }

    onProgress?.(i + 1, TOP_15.length, label);
  }

  return history;
}

/**
 * Force a full re-download on the next loadPriceData() call.
 */
export async function clearPriceCache(): Promise<void> {
  try {
    const db = await openDB();
    await idbClear(db);
  } catch (e) {
    console.warn("[priceData] clearPriceCache failed:", e);
  }
}

/**
 * Per-asset freshness for UI diagnostics.
 * ageHours = hours since last save; fresh = age < 12 h.
 */
export async function getPriceFreshness(): Promise<
  { symbol: string; label: string; fresh: boolean; ageHours: number }[]
> {
  try {
    const db  = await openDB();
    const now = Date.now();
    return await Promise.all(
      TOP_15.map(async (label) => {
        const rec = await idbGet(db, label);
        const age = rec ? (now - rec.ts) / 3_600_000 : Infinity;
        return { symbol: label, label, fresh: age < 12, ageHours: +age.toFixed(1) };
      }),
    );
  } catch {
    return TOP_15.map((label) => ({
      symbol: label, label, fresh: false, ageHours: Infinity,
    }));
  }
}
